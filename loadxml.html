<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ṭbetis sulta maṭiane - Complete Prosopographical Database</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Times New Roman', serif;
            line-height: 1.5;
            color: #000;
            background: #fff;
            font-size: 14px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            border-bottom: 1px solid #ccc;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 24px;
            font-weight: normal;
            margin-bottom: 8px;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            font-size: 16px;
            font-style: italic;
            margin-bottom: 15px;
        }

        .manuscript-info {
            font-size: 12px;
            text-align: center;
            color: #666;
            border: 1px solid #ddd;
            padding: 10px;
        }

        .file-upload {
            border: 1px solid #ddd;
            padding: 15px;
            margin-bottom: 20px;
            background: #f9f9f9;
        }

        .upload-area {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .search-controls {
            border: 1px solid #ddd;
            padding: 20px;
            margin-bottom: 20px;
        }

        .search-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 10px;
        }

        input, select {
            padding: 6px 8px;
            border: 1px solid #999;
            font-family: inherit;
            font-size: 13px;
        }

        input:focus, select:focus {
            outline: 1px solid #000;
            border-color: #000;
        }

        button {
            background: #fff;
            border: 1px solid #999;
            padding: 6px 12px;
            cursor: pointer;
            font-family: inherit;
            font-size: 13px;
        }

        button:hover {
            background: #f5f5f5;
        }

        button:active {
            background: #eee;
        }

        .primary-btn {
            background: #000;
            color: #fff;
        }

        .primary-btn:hover {
            background: #333;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            border: 1px solid #ddd;
            padding: 15px;
            text-align: center;
        }

        .stat-number {
            font-size: 20px;
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .results {
            border: 1px solid #ddd;
        }

        .results-header {
            background: #f8f8f8;
            border-bottom: 1px solid #ddd;
            padding: 10px 15px;
            font-weight: bold;
            font-size: 13px;
        }

        .person-card {
            border-bottom: 1px solid #eee;
            padding: 15px;
        }

        .person-card:last-child {
            border-bottom: none;
        }

        .person-name {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .person-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 8px;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .detail-item {
            display: flex;
        }

        .detail-label {
            font-weight: bold;
            margin-right: 8px;
            min-width: 70px;
        }

        .family-members {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #eee;
            background: #fafafa;
        }

        .family-title {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .family-member {
            display: inline-block;
            margin: 2px 8px 2px 0;
            font-size: 12px;
            border: 1px solid #ddd;
            padding: 2px 6px;
            background: #fff;
        }

        .dates-info {
            margin-top: 8px;
            padding: 8px;
            border: 1px solid #e0e0e0;
            background: #f8f8f8;
            font-size: 12px;
        }

        .no-results {
            text-align: center;
            padding: 40px 20px;
            font-style: italic;
            color: #666;
        }

        .georgian-text {
            font-family: 'DejaVu Sans', 'Arial Unicode MS', sans-serif;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 12px;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 6px 8px;
            text-align: left;
            vertical-align: top;
        }

        th {
            background: #f8f8f8;
            font-weight: bold;
            font-size: 11px;
        }

        .view-toggle {
            margin-bottom: 15px;
        }

        .view-toggle button {
            margin-right: 5px;
        }

        .view-toggle button.active {
            background: #000;
            color: #fff;
        }

        .status-message {
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 768px) {
            .search-row, .upload-area {
                grid-template-columns: 1fr;
                flex-direction: column;
            }

            .person-details {
                grid-template-columns: 1fr;
            }

            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div style="text-align: right; margin-bottom: 15px;">
                <button onclick="toggleLanguage()" id="langToggle">ქართული</button>
            </div>
            <h1 id="mainTitle">Ṭbetis sulta maṭiane</h1>
            <div class="subtitle" id="subtitle">Complete Synodal Records from Ṭbeti - Prosopographical Database</div>
            <div class="manuscript-info">
                <strong id="msLabel">Manuscript:</strong> St. Petersburg, Russian National Library, P10/P13 |
                <strong id="periodLabel">Period:</strong> <span id="periodText">Medieval (10th-15th centuries)</span> |
                <strong id="languageLabel">Language:</strong> <span id="languageText">Old Georgian</span> |
                <strong id="scriptLabel">Script:</strong> Nuskhuri
            </div>
        </header>

        <div class="file-upload">
            <div style="font-weight: bold; margin-bottom: 10px;" id="uploadTitle">XML Data Import</div>
            <div class="upload-area">
                <input type="file" id="xmlFileInput" accept=".xml" />
                <button onclick="loadXMLFile()" class="primary-btn" id="loadBtn">Load XML File</button>
                <button onclick="loadSampleData()" id="sampleBtn">Load Sample Data</button>
                <span id="fileStatus">No file selected</span>
            </div>
            <div id="statusMessage"></div>
        </div>

        <div class="search-controls">
            <div class="search-row">
                <input type="text" id="nameSearch" placeholder="Name">
                <input type="text" id="surnameSearch" placeholder="Surname/Patronymic">
                <select id="typeFilter">
                    <option value="" id="allTypesOption">All types</option>
                    <option value="main" id="mainOption">Main person</option>
                    <option value="wife" id="wifeOption">Wife</option>
                    <option value="son" id="sonOption">Son</option>
                    <option value="daughter" id="daughterOption">Daughter</option>
                    <option value="brother" id="brotherOption">Brother</option>
                    <option value="sister" id="sisterOption">Sister</option>
                    <option value="mother" id="motherOption">Mother</option>
                    <option value="father" id="fatherOption">Father</option>
                    <option value="evangelist" id="evangelistOption">Evangelist</option>
                    <option value="bishop" id="bishopOption">Bishop</option>
                    <option value="priest" id="priestOption">Priest</option>
                    <option value="monk" id="monkOption">Monk</option>
                </select>
                <input type="text" id="placeSearch" placeholder="Place">
            </div>
            <div class="search-row">
                <input type="text" id="occupationSearch" placeholder="Occupation/Title">
                <input type="text" id="dateSearch" placeholder="Date/Century">
                <input type="text" id="manuscriptSearch" placeholder="Folio (e.g., Ir, IIv)">
                <button onclick="performSearch()" id="searchBtn">Search</button>
            </div>
            <div class="search-row">
                <button onclick="clearSearch()" id="clearBtn">Clear</button>
                <button onclick="showAll()" id="showAllBtn">Show All</button>
                <button onclick="exportData('csv')" id="exportBtn">Export CSV</button>
                <button onclick="exportData('json')" id="exportJsonBtn">Export JSON</button>
            </div>
        </div>

        <div class="stats">
            <div class="stat-card">
                <span class="stat-number" id="totalEntries">0</span>
                <span class="stat-label" id="entriesLabel">Entries</span>
            </div>
            <div class="stat-card">
                <span class="stat-number" id="totalPersons">0</span>
                <span class="stat-label" id="personsLabel">Persons</span>
            </div>
            <div class="stat-card">
                <span class="stat-number" id="uniqueSurnames">0</span>
                <span class="stat-label" id="surnamesLabel">Surnames</span>
            </div>
            <div class="stat-card">
                <span class="stat-number" id="placesCount">0</span>
                <span class="stat-label" id="placesLabel">Places</span>
            </div>
            <div class="stat-card">
                <span class="stat-number" id="occupationsCount">0</span>
                <span class="stat-label" id="occupationsLabel">Occupations</span>
            </div>
        </div>

        <div class="view-toggle">
            <button onclick="setView('cards')" id="cardsBtn" class="active">Card View</button>
            <button onclick="setView('table')" id="tableBtn">Table View</button>
        </div>

        <div class="results">
            <div class="results-header">
                <span id="resultsCount">Loading...</span>
            </div>
            <div id="resultsContainer">
                <div class="no-results" id="loadingText">Ready to load prosopographical data...</div>
            </div>
        </div>
    </div>

    <script>
        let prosopographicalData = [];
        let currentResults = [];
        let currentView = 'cards';
        let currentLanguage = 'en';

        // Language translations
        const translations = {
            en: {
                mainTitle: "Ṭbetis sulta maṭiane",
                subtitle: "Complete Synodal Records from Ṭbeti - Prosopographical Database",
                msLabel: "Manuscript:",
                periodLabel: "Period:",
                periodText: "Medieval (10th-15th centuries)",
                languageLabel: "Language:",
                languageText: "Old Georgian",
                scriptLabel: "Script:",
                uploadTitle: "XML Data Import",
                loadBtn: "Load XML File",
                sampleBtn: "Load Sample Data",
                fileStatus: "No file selected",
                namePlaceholder: "Name",
                surnamePlaceholder: "Surname/Patronymic",
                placePlaceholder: "Place",
                occupationPlaceholder: "Occupation/Title",
                datePlaceholder: "Date/Century",
                manuscriptPlaceholder: "Folio (e.g., Ir, IIv)",
                allTypesOption: "All types",
                mainOption: "Main person",
                wifeOption: "Wife",
                sonOption: "Son",
                daughterOption: "Daughter",
                brotherOption: "Brother",
                sisterOption: "Sister",
                motherOption: "Mother",
                fatherOption: "Father",
                evangelistOption: "Evangelist",
                bishopOption: "Bishop",
                priestOption: "Priest",
                monkOption: "Monk",
                searchBtn: "Search",
                clearBtn: "Clear",
                showAllBtn: "Show All",
                exportBtn: "Export CSV",
                exportJsonBtn: "Export JSON",
                entriesLabel: "Entries",
                personsLabel: "Persons",
                surnamesLabel: "Surnames",
                placesLabel: "Places",
                occupationsLabel: "Occupations",
                cardViewBtn: "Card View",
                tableViewBtn: "Table View",
                entriesFound: "entries",
                noEntriesFound: "No entries found.",
                loading: "Ready to load prosopographical data...",
                entryLabel: "Entry:",
                typeLabel: "Type:",
                placeLabel: "Place:",
                occupationLabel: "Occupation:",
                dateLabel: "Date:",
                msLabel2: "MS:",
                edLabel: "Ed:",
                familyTitle: "Family:",
                datesTitle: "Dating:",
                tableHeaders: {
                    entry: "Entry",
                    name: "Name",
                    surname: "Surname",
                    type: "Type",
                    place: "Place",
                    occupation: "Occupation",
                    family: "Family",
                    msRef: "MS Ref",
                    dates: "Dates"
                },
                langToggle: "ქართული",
                loadSuccess: "XML file loaded successfully!",
                loadError: "Error loading XML file. Using sample data.",
                parseError: "Error parsing XML structure.",
                fileSelected: "File selected:",
                processing: "Processing XML data..."
            },
            ka: {
                mainTitle: "ტბეთის სულთა მატიანე",
                subtitle: "ტბეთის სინოდიკონი - სრული პროსოპოგრაფიული მონაცემთა ბაზა",
                msLabel: "ხელნაწერი:",
                periodLabel: "პერიოდი:",
                periodText: "შუასაუკუნეები (X-XV საუკუნეები)",
                languageLabel: "ენა:",
                languageText: "ძველი ქართული",
                scriptLabel: "დამწერლობა:",
                uploadTitle: "XML მონაცემთა იმპორტი",
                loadBtn: "XML ფაილის ჩატვირთვა",
                sampleBtn: "ნიმუშის მონაცემების ჩატვირთვა",
                fileStatus: "ფაილი არ არის არჩეული",
                namePlaceholder: "სახელი",
                surnamePlaceholder: "გვარი/მამისახელი",
                placePlaceholder: "ადგილი",
                occupationPlaceholder: "პროფესია/წოდება",
                datePlaceholder: "თარიღი/საუკუნე",
                manuscriptPlaceholder: "ფოლიო (მაგ., Ir, IIv)",
                allTypesOption: "ყველა ტიპი",
                mainOption: "მთავარი პირი",
                wifeOption: "მეუღლე",
                sonOption: "შვილი",
                daughterOption: "ასული",
                brotherOption: "ძმა",
                sisterOption: "და",
                motherOption: "დედა",
                fatherOption: "მამა",
                evangelistOption: "მახარებელი",
                bishopOption: "ეპისკოპოსი",
                priestOption: "მღვდელი",
                monkOption: "ბერი",
                searchBtn: "ძიება",
                clearBtn: "გასუფთავება",
                showAllBtn: "ყველას ჩვენება",
                exportBtn: "CSV ექსპორტი",
                exportJsonBtn: "JSON ექსპორტი",
                entriesLabel: "ჩანაწერები",
                personsLabel: "პირები",
                surnamesLabel: "გვარები",
                placesLabel: "ადგილები",
                occupationsLabel: "პროფესიები",
                cardViewBtn: "ბარათების ხედი",
                tableViewBtn: "ცხრილის ხედი",
                entriesFound: "ჩანაწერი",
                noEntriesFound: "ჩანაწერები ვერ მოიძებნა.",
                loading: "პროსოპოგრაფიული მონაცემების ჩასატვირთად მზად.",
                entryLabel: "ჩანაწერი:",
                typeLabel: "ტიპი:",
                placeLabel: "ადგილი:",
                occupationLabel: "პროფესია:",
                dateLabel: "თარიღი:",
                msLabel2: "ხნ:",
                edLabel: "გამოც:",
                familyTitle: "ოჯახი:",
                datesTitle: "დათარიღება:",
                tableHeaders: {
                    entry: "ჩანაწერი",
                    name: "სახელი",
                    surname: "გვარი",
                    type: "ტიპი",
                    place: "ადგილი",
                    occupation: "პროფესია",
                    family: "ოჯახი",
                    msRef: "ხნ. მით.",
                    dates: "თარიღები"
                },
                langToggle: "English",
                loadSuccess: "XML ფაილი წარმატებით ჩაიტვირთა!",
                loadError: "შეცდომა XML ფაილის ჩატვირთვისას. ნიმუშის მონაცემების გამოყენება.",
                parseError: "შეცდომა XML სტრუქტურის ანალიზისას.",
                fileSelected: "ფაილი არჩეულია:",
                processing: "XML მონაცემების დამუშავება..."
            }
        };

        // XML Parser Class
        class TbetiXMLParser {
            constructor() {
                this.entries = [];
                this.statistics = {
                    totalEntries: 0,
                    totalPersons: 0,
                    uniqueSurnames: new Set(),
                    places: new Set(),
                    occupations: new Set()
                };
            }

            parseXMLDocument(xmlString) {
                try {
                    // Clean the XML string
                    xmlString = xmlString.trim();

                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlString, "text/xml");

                    // Check for parsing errors
                    const parserErrors = xmlDoc.getElementsByTagName("parsererror");
                    if (parserErrors.length > 0) {
                        console.error("XML Parser Error:", parserErrors[0].textContent);
                        throw new Error("Invalid XML structure");
                    }

                    // Log XML structure for debugging
                    console.log("XML Root Element:", xmlDoc.documentElement.tagName);
                    console.log("XML Structure:", this.analyzeXMLStructure(xmlDoc));

                    // Try to parse entries
                    this.parseEntries(xmlDoc);

                    if (this.entries.length === 0) {
                        console.warn("No entries found in XML. Trying alternative parsing methods...");
                        this.tryAlternativeParsing(xmlDoc);
                    }

                    this.calculateStatistics();

                    return this.entries;
                } catch (error) {
                    console.error("Error parsing XML:", error);
                    console.log("Falling back to sample data");
                    return this.generateSampleData();
                }
            }

            analyzeXMLStructure(xmlDoc) {
                const root = xmlDoc.documentElement;
                const structure = {
                    rootTag: root.tagName,
                    children: Array.from(root.children).map(child => ({
                        tag: child.tagName,
                        count: root.getElementsByTagName(child.tagName).length,
                        hasText: child.textContent.trim().length > 0,
                        hasGeorgian: /[\u10A0-\u10FF]/.test(child.textContent)
                    }))
                };
                return structure;
            }

            tryAlternativeParsing(xmlDoc) {
                // Try different XML structures
                const root = xmlDoc.documentElement;

                // Method 1: Look for any elements with Georgian text
                const allElements = Array.from(xmlDoc.getElementsByTagName('*'));
                const georgianElements = allElements.filter(el =>
                    /[\u10A0-\u10FF]/.test(el.textContent) &&
                    el.children.length === 0 // leaf nodes
                );

                if (georgianElements.length > 0) {
                    console.log("Found Georgian text elements:", georgianElements.length);
                    this.parseFromGeorgianElements(georgianElements);
                    return;
                }

                // Method 2: Try parsing from text content directly
                const textContent = xmlDoc.textContent || xmlDoc.innerText || '';
                if (textContent.trim()) {
                    console.log("Trying to parse from text content...");
                    this.parseFromTextContent(textContent);
                }
            }

            parseFromGeorgianElements(elements) {
                let entryNumber = 1;
                elements.forEach(element => {
                    const text = element.textContent.trim();
                    if (text && /[\u10A0-\u10FF]/.test(text)) {
                        const entry = this.createEntryFromText(text, entryNumber++);
                        if (entry) {
                            this.entries.push(entry);
                        }
                    }
                });
            }

            parseFromTextContent(textContent) {
                // Split by lines or common separators
                const lines = textContent.split(/[\n\r]+/).filter(line =>
                    line.trim() && /[\u10A0-\u10FF]/.test(line)
                );

                lines.forEach((line, index) => {
                    const entry = this.createEntryFromText(line, index + 1);
                    if (entry) {
                        this.entries.push(entry);
                    }
                });
            }

            createEntryFromText(text, entryNumber) {
                try {
                    // Create a temporary DOM element to help with parsing
                    const tempDiv = document.createElement('div');
                    tempDiv.textContent = text;

                    const entry = {
                        entryId: `entry_${entryNumber.toString().padStart(3, '0')}`,
                        entryNumber: entryNumber,
                        mainPerson: {},
                        familyMembers: [],
                        manuscript: {},
                        edition: {},
                        dates: {},
                        notes: text // Store original text as notes
                    };

                    // Parse main person from text
                    entry.mainPerson = this.parseMainPersonFromText(text);

                    // Parse family members from text
                    entry.familyMembers = this.parseFamilyMembersFromText(text);

                    // Parse manuscript references from text
                    entry.manuscript = this.parseManuscriptRefFromText(text);

                    // Parse dates from text
                    entry.dates = this.parseDatesFromText(text);

                    return entry;
                } catch (error) {
                    console.warn(`Error creating entry from text: ${text}`, error);
                    return null;
                }
            }

            parseMainPersonFromText(text) {
                const person = {
                    name: "",
                    surname: "",
                    patronymic: "",
                    type: "main",
                    occupation: "",
                    place: ""
                };

                // Extract Georgian name (first Georgian word found)
                const georgianWords = text.match(/[\u10A0-\u10FF]+/g);
                if (georgianWords && georgianWords.length > 0) {
                    person.name = georgianWords[0];
                }

                // Look for patronymic patterns
                const patronymicMatch = text.match(/([\u10A0-\u10FF]+(?:შვილი|სძე))/);
                if (patronymicMatch) {
                    person.patronymic = patronymicMatch[1];
                }

                // Determine type/occupation
                person.type = this.determinePersonType(text);
                if (person.type !== 'main') {
                    person.occupation = person.type;
                }

                return person;
            }

            parseFamilyMembersFromText(text) {
                const familyMembers = [];

                const relationshipPatterns = [
                    { pattern: /([\u10A0-\u10FF]+)\s*მეუღლესა/g, type: 'wife', relationship: 'მეუღლესა' },
                    { pattern: /([\u10A0-\u10FF]+)\s*მეუღლისა/g, type: 'wife', relationship: 'მეუღლისა' },
                    { pattern: /([\u10A0-\u10FF]+)\s*შვილი/g, type: 'son', relationship: 'შვილი' },
                    { pattern: /([\u10A0-\u10FF]+)\s*ასული/g, type: 'daughter', relationship: 'ასული' },
                    { pattern: /([\u10A0-\u10FF]+)\s*ძმასა/g, type: 'brother', relationship: 'ძმასა' },
                    { pattern: /([\u10A0-\u10FF]+)\s*დასა/g, type: 'sister', relationship: 'დასა' }
                ];

                relationshipPatterns.forEach(({ pattern, type, relationship }) => {
                    let match;
                    while ((match = pattern.exec(text)) !== null) {
                        const name = match[1].trim();
                        if (name && !this.isCommonWord(name)) {
                            familyMembers.push({ name, type, relationship });
                        }
                    }
                });

                return familyMembers;
            }

            parseManuscriptRefFromText(text) {
                const manuscript = { page: "", line: "", folio: "" };

                const folioMatch = text.match(/f?\.\s*([IVXivx]+[rv]?|\d+[rv]?)/i);
                if (folioMatch) {
                    manuscript.folio = folioMatch[1];
                    manuscript.page = folioMatch[1];
                }

                const lineMatch = text.match(/l(?:ines?)?\.\s*(\d+(?:-\d+)?)/i);
                if (lineMatch) {
                    manuscript.line = lineMatch[1];
                }

                return manuscript;
            }

            parseDatesFromText(text) {
                const dates = { year: "", century: "", period: "" };

                const yearMatch = text.match(/(\d{3,4})/);
                if (yearMatch) {
                    dates.year = yearMatch[1];
                }

                const centuryMatch = text.match(/(XI{1,3}|IX|X|XII|XIII|XIV|XV)\s*c/i);
                if (centuryMatch) {
                    dates.century = centuryMatch[1];
                }

                return dates;
            }

            parseEntries(xmlDoc) {
                let entryNodes = this.findEntryNodes(xmlDoc);

                entryNodes.forEach((entryNode, index) => {
                    const entry = this.parseEntry(entryNode, index + 1);
                    if (entry) {
                        this.entries.push(entry);
                    }
                });
            }

            findEntryNodes(xmlDoc) {
                const possibleSelectors = [
                    'entry', 'person', 'record', 'item', 'synodicon_entry', 'commemoration', 'memorial'
                ];

                for (let selector of possibleSelectors) {
                    const nodes = xmlDoc.getElementsByTagName(selector);
                    if (nodes.length > 0) {
                        return Array.from(nodes);
                    }
                }

                const allElements = xmlDoc.getElementsByTagName('*');
                return Array.from(allElements).filter(el =>
                    el.children.length > 0 && this.looksLikePersonEntry(el)
                );
            }

            looksLikePersonEntry(element) {
                const text = element.textContent.toLowerCase();
                const georgianNamePattern = /[\u10A0-\u10FF]/;

                return georgianNamePattern.test(text) && (
                    text.includes('მეუღლე') || text.includes('შვილი') ||
                    text.includes('ასული') || text.includes('ძმა') ||
                    element.children.length >= 2
                );
            }

            parseEntry(entryNode, entryNumber) {
                try {
                    const entry = {
                        entryId: `entry_${entryNumber.toString().padStart(3, '0')}`,
                        entryNumber: entryNumber,
                        mainPerson: this.parseMainPerson(entryNode),
                        familyMembers: this.parseFamilyMembers(entryNode),
                        manuscript: this.parseManuscriptRef(entryNode),
                        edition: this.parseEditionRef(entryNode),
                        dates: this.parseDates(entryNode),
                        notes: this.parseNotes(entryNode)
                    };
                    return entry;
                } catch (error) {
                    console.warn(`Error parsing entry ${entryNumber}:`, error);
                    return null;
                }
            }

            parseMainPerson(entryNode) {
                const person = {
                    name: "",
                    surname: "",
                    patronymic: "",
                    type: "main",
                    occupation: "",
                    place: ""
                };

                person.name = this.extractGeorgianName(entryNode.textContent);

                const surnameText = this.extractText(entryNode, ['surname', 'family_name', 'patronymic']);
                if (surnameText) {
                    if (surnameText.includes('შვილი') || surnameText.includes('სძე')) {
                        person.patronymic = surnameText;
                    } else {
                        person.surname = surnameText;
                    }
                }

                person.occupation = this.extractText(entryNode, ['occupation', 'role', 'title']);
                person.place = this.extractText(entryNode, ['place', 'location', 'origin']);
                person.type = this.determinePersonType(entryNode.textContent);

                return person;
            }

            parseFamilyMembers(entryNode) {
                const familyMembers = [];
                const text = entryNode.textContent;

                const relationshipPatterns = [
                    { pattern: /(\S+)\s*მეუღლესა/g, type: 'wife', relationship: 'მეუღლესა' },
                    { pattern: /(\S+)\s*მეუღლისა/g, type: 'wife', relationship: 'მეუღლისა' },
                    { pattern: /(\S+)\s*შვილი/g, type: 'son', relationship: 'შვილი' },
                    { pattern: /(\S+)\s*ასული/g, type: 'daughter', relationship: 'ასული' },
                    { pattern: /(\S+)\s*ძმასა/g, type: 'brother', relationship: 'ძმასა' },
                    { pattern: /(\S+)\s*დასა/g, type: 'sister', relationship: 'დასა' },
                    { pattern: /(\S+)\s*დედასა/g, type: 'mother', relationship: 'დედასა' },
                    { pattern: /(\S+)\s*მამასა/g, type: 'father', relationship: 'მამასა' }
                ];

                relationshipPatterns.forEach(({ pattern, type, relationship }) => {
                    let match;
                    while ((match = pattern.exec(text)) !== null) {
                        const name = match[1].trim();
                        if (name && !this.isCommonWord(name)) {
                            familyMembers.push({ name, type, relationship });
                        }
                    }
                });

                return familyMembers;
            }

            parseManuscriptRef(entryNode) {
                const manuscript = { page: "", line: "", folio: "" };
                const text = entryNode.textContent;

                const folioMatch = text.match(/f?\.\s*([IVXivx]+[rv]?|\d+[rv]?)/i);
                if (folioMatch) {
                    manuscript.folio = folioMatch[1];
                    manuscript.page = folioMatch[1];
                }

                const lineMatch = text.match(/l(?:ines?)?\.\s*(\d+(?:-\d+)?)/i);
                if (lineMatch) {
                    manuscript.line = lineMatch[1];
                }

                return manuscript;
            }

            parseEditionRef(entryNode) {
                const edition = { page: "", line: "" };
                const text = entryNode.textContent;

                const pageMatch = text.match(/p(?:age)?\.\s*(\d+)/i);
                if (pageMatch) {
                    edition.page = pageMatch[1];
                }

                const lineMatch = text.match(/ed\.\s*l(?:ine)?\.\s*(\d+(?:-\d+)?)/i);
                if (lineMatch) {
                    edition.line = lineMatch[1];
                }

                return edition;
            }

            parseDates(entryNode) {
                const dates = { year: "", century: "", period: "" };
                const text = entryNode.textContent;

                const yearMatch = text.match(/(\d{3,4})/);
                if (yearMatch) {
                    dates.year = yearMatch[1];
                }

                const centuryMatch = text.match(/(XI{1,3}|IX|X|XII|XIII|XIV|XV)\s*c/i);
                if (centuryMatch) {
                    dates.century = centuryMatch[1];
                }

                return dates;
            }

            parseNotes(entryNode) {
                return this.extractText(entryNode, ['note', 'comment', 'remarks']) || "";
            }

            extractText(node, tagNames) {
                for (let tagName of tagNames) {
                    const element = node.getElementsByTagName(tagName)[0] || node.querySelector(tagName);
                    if (element) {
                        return element.textContent.trim();
                    }
                }
                return "";
            }

            extractGeorgianName(text) {
                const georgianPattern = /[\u10A0-\u10FF]+/g;
                const matches = text.match(georgianPattern);
                return matches ? matches[0] : "";
            }

            determinePersonType(text) {
                if (text.includes('მახარებელი')) return 'evangelist';
                if (text.includes('ეპისკოპოსი')) return 'bishop';
                if (text.includes('მღვდელი')) return 'priest';
                if (text.includes('ბერი')) return 'monk';
                return 'main';
            }

            isCommonWord(word) {
                const commonWords = ['და', 'ან', 'თუ', 'არ', 'იყო', 'არა', 'მას', 'ის', 'ამ'];
                return commonWords.includes(word);
            }

            calculateStatistics() {
                this.statistics.totalEntries = this.entries.length;

                this.entries.forEach(entry => {
                    this.statistics.totalPersons += 1 + (entry.familyMembers?.length || 0);

                    if (entry.mainPerson.surname) {
                        this.statistics.uniqueSurnames.add(entry.mainPerson.surname);
                    }
                    if (entry.mainPerson.patronymic) {
                        this.statistics.uniqueSurnames.add(entry.mainPerson.patronymic);
                    }
                    if (entry.mainPerson.place) {
                        this.statistics.places.add(entry.mainPerson.place);
                    }
                    if (entry.mainPerson.occupation) {
                        this.statistics.occupations.add(entry.mainPerson.occupation);
                    }
                });
            }

            generateSampleData() {
                return [
                    {
                        entryId: "entry_001",
                        entryNumber: 1,
                        mainPerson: {
                            name: "მახარებელი",
                            type: "evangelist",
                            place: "გორგაზიეთ",
                            occupation: "evangelist"
                        },
                        familyMembers: [
                            { name: "მარიამი", type: "wife", relationship: "მეუღლესა" },
                            { name: "თამარი", type: "daughter", relationship: "ასული" }
                        ],
                        manuscript: { line: "2-4", page: "Ir", folio: "Ir" },
                        edition: { line: "2-3", page: "60" },
                        dates: { century: "XI", period: "medieval" },
                        notes: "Evangelist from Gorgaziet"
                    },
                    {
                        entryId: "entry_002",
                        entryNumber: 2,
                        mainPerson: {
                            name: "კუირიკე",
                            place: "გორგაზიეთ"
                        },
                        familyMembers: [
                            { name: "თინა", type: "wife", relationship: "მეუღლისა" },
                            { name: "ცხორება", type: "woman", relationship: "ქალისა" }
                        ],
                        manuscript: { line: "5-7", page: "Ir" },
                        edition: { line: "4-6", page: "60" },
                        dates: { century: "XI" },
                        notes: ""
                    },
                    {
                        entryId: "entry_003",
                        entryNumber: 3,
                        mainPerson: {
                            name: "იოვანე",
                            patronymic: "გულქანისშვილი"
                        },
                        familyMembers: [
                            { name: "მარიამი", type: "wife", relationship: "მეუღლისა" }
                        ],
                        manuscript: { line: "8-9", page: "Ir" },
                        edition: { line: "7-8", page: "60" },
                        dates: { century: "XI" },
                        notes: ""
                    },
                    {
                        entryId: "entry_004",
                        entryNumber: 4,
                        mainPerson: {
                            name: "გიორგი",
                            surname: "ხაპერასძე"
                        },
                        familyMembers: [
                            { name: "ნათელი", type: "wife", relationship: "მეუღლისა" }
                        ],
                        manuscript: { line: "10", page: "Ir" },
                        edition: { line: "9-10", page: "60" },
                        dates: { century: "XI" },
                        notes: ""
                    },
                    {
                        entryId: "entry_005",
                        entryNumber: 5,
                        mainPerson: {
                            name: "მიქაელი",
                            surname: "კაკალისძე"
                        },
                        familyMembers: [
                            { name: "რუსუდანი", type: "wife", relationship: "მეუღლისა" }
                        ],
                        manuscript: { line: "11-12", page: "Ir" },
                        edition: { line: "11-12", page: "60" },
                        dates: { century: "XI" },
                        notes: ""
                    },
                    {
                        entryId: "entry_006",
                        entryNumber: 6,
                        mainPerson: {
                            name: "დავითი",
                            surname: "მცხეთელი",
                            occupation: "bishop"
                        },
                        familyMembers: [
                            { name: "ანა", type: "wife", relationship: "მეუღლისა" },
                            { name: "გიორგი", type: "son", relationship: "შვილი" }
                        ],
                        manuscript: { line: "13-15", page: "Ir" },
                        edition: { line: "13-15", page: "60" },
                        dates: { century: "XI", year: "1045" },
                        notes: "Bishop of Mtskheta"
                    }
                ];
            }

            getStatistics() {
                return {
                    totalEntries: this.statistics.totalEntries,
                    totalPersons: this.statistics.totalPersons,
                    uniqueSurnames: this.statistics.uniqueSurnames.size,
                    places: this.statistics.places.size,
                    occupations: this.statistics.occupations.size
                };
            }
        }

        // Main application functions
        function toggleLanguage() {
            currentLanguage = currentLanguage === 'en' ? 'ka' : 'en';
            updateUILanguage();
        }

        function updateUILanguage() {
            const t = translations[currentLanguage];

            // Update header
            document.getElementById('mainTitle').textContent = t.mainTitle;
            document.getElementById('subtitle').textContent = t.subtitle;
            document.getElementById('msLabel').textContent = t.msLabel;
            document.getElementById('periodLabel').textContent = t.periodLabel;
            document.getElementById('periodText').textContent = t.periodText;
            document.getElementById('languageLabel').textContent = t.languageLabel;
            document.getElementById('languageText').textContent = t.languageText;
            document.getElementById('scriptLabel').textContent = t.scriptLabel;

            // Update upload section
            document.getElementById('uploadTitle').textContent = t.uploadTitle;
            document.getElementById('loadBtn').textContent = t.loadBtn;
            document.getElementById('sampleBtn').textContent = t.sampleBtn;

            // Update search controls
            document.getElementById('nameSearch').placeholder = t.namePlaceholder;
            document.getElementById('surnameSearch').placeholder = t.surnamePlaceholder;
            document.getElementById('placeSearch').placeholder = t.placePlaceholder;
            document.getElementById('occupationSearch').placeholder = t.occupationPlaceholder;
            document.getElementById('dateSearch').placeholder = t.datePlaceholder;
            document.getElementById('manuscriptSearch').placeholder = t.manuscriptPlaceholder;

            // Update select options
            document.getElementById('allTypesOption').textContent = t.allTypesOption;
            document.getElementById('mainOption').textContent = t.mainOption;
            document.getElementById('wifeOption').textContent = t.wifeOption;
            document.getElementById('sonOption').textContent = t.sonOption;
            document.getElementById('daughterOption').textContent = t.daughterOption;
            document.getElementById('brotherOption').textContent = t.brotherOption;
            document.getElementById('sisterOption').textContent = t.sisterOption;
            document.getElementById('motherOption').textContent = t.motherOption;
            document.getElementById('fatherOption').textContent = t.fatherOption;
            document.getElementById('evangelistOption').textContent = t.evangelistOption;
            document.getElementById('bishopOption').textContent = t.bishopOption;
            document.getElementById('priestOption').textContent = t.priestOption;
            document.getElementById('monkOption').textContent = t.monkOption;

            // Update buttons
            document.getElementById('searchBtn').textContent = t.searchBtn;
            document.getElementById('clearBtn').textContent = t.clearBtn;
            document.getElementById('showAllBtn').textContent = t.showAllBtn;
            document.getElementById('exportBtn').textContent = t.exportBtn;
            document.getElementById('exportJsonBtn').textContent = t.exportJsonBtn;

            // Update stats
            document.getElementById('entriesLabel').textContent = t.entriesLabel;
            document.getElementById('personsLabel').textContent = t.personsLabel;
            document.getElementById('surnamesLabel').textContent = t.surnamesLabel;
            document.getElementById('placesLabel').textContent = t.placesLabel;
            document.getElementById('occupationsLabel').textContent = t.occupationsLabel;

            // Update view toggle
            document.getElementById('cardsBtn').textContent = t.cardViewBtn;
            document.getElementById('tableBtn').textContent = t.tableViewBtn;

            // Update language toggle button
            document.getElementById('langToggle').textContent = t.langToggle;

            displayResults();
        }

        function showStatusMessage(message, isError = false) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.innerHTML = `<div class="status-message ${isError ? 'status-error' : 'status-success'}">${message}</div>`;
            setTimeout(() => {
                statusDiv.innerHTML = '';
            }, 5000);
        }

        function loadXMLFile() {
            const fileInput = document.getElementById('xmlFileInput');
            const file = fileInput.files[0];

            if (!file) {
                showStatusMessage(translations[currentLanguage].loadError, true);
                return;
            }

            const t = translations[currentLanguage];
            showStatusMessage(t.processing);

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const xmlContent = e.target.result;
                    const parser = new TbetiXMLParser();
                    prosopographicalData = parser.parseXMLDocument(xmlContent);

                    updateStatistics();
                    showAll();
                    showStatusMessage(`${t.loadSuccess} ${prosopographicalData.length} entries loaded.`);
                } catch (error) {
                    console.error('Error processing XML:', error);
                    loadSampleData();
                    showStatusMessage(t.parseError, true);
                }
            };

            reader.onerror = function() {
                showStatusMessage(translations[currentLanguage].loadError, true);
                loadSampleData();
            };

            reader.readAsText(file);
        }

        function loadSampleData() {
            const parser = new TbetiXMLParser();
            prosopographicalData = parser.generateSampleData();
            updateStatistics();
            updateUILanguage();
            showAll();
        }

        function updateStatistics() {
            const totalEntries = prosopographicalData.length;
            const allPersons = [];
            const surnames = new Set();
            const places = new Set();
            const occupations = new Set();

            prosopographicalData.forEach(entry => {
                allPersons.push(entry.mainPerson);
                if (entry.mainPerson.surname) surnames.add(entry.mainPerson.surname);
                if (entry.mainPerson.patronymic) surnames.add(entry.mainPerson.patronymic);
                if (entry.mainPerson.place) places.add(entry.mainPerson.place);
                if (entry.mainPerson.occupation) occupations.add(entry.mainPerson.occupation);

                if (entry.familyMembers) {
                    entry.familyMembers.forEach(member => {
                        allPersons.push(member);
                    });
                }
            });

            document.getElementById('totalEntries').textContent = totalEntries;
            document.getElementById('totalPersons').textContent = allPersons.length;
            document.getElementById('uniqueSurnames').textContent = surnames.size;
            document.getElementById('placesCount').textContent = places.size;
            document.getElementById('occupationsCount').textContent = occupations.size;
        }

        function performSearch() {
            const nameSearch = document.getElementById('nameSearch').value.toLowerCase();
            const surnameSearch = document.getElementById('surnameSearch').value.toLowerCase();
            const typeFilter = document.getElementById('typeFilter').value;
            const placeSearch = document.getElementById('placeSearch').value.toLowerCase();
            const occupationSearch = document.getElementById('occupationSearch').value.toLowerCase();
            const dateSearch = document.getElementById('dateSearch').value.toLowerCase();
            const manuscriptSearch = document.getElementById('manuscriptSearch').value.toLowerCase();

            currentResults = prosopographicalData.filter(entry => {
                const mainMatch = matchesPerson(entry.mainPerson, nameSearch, surnameSearch, typeFilter, placeSearch, occupationSearch) &&
                                 matchesDates(entry.dates, dateSearch) &&
                                 matchesManuscript(entry.manuscript, manuscriptSearch);

                const familyMatch = entry.familyMembers && entry.familyMembers.some(member =>
                    matchesPerson(member, nameSearch, surnameSearch, typeFilter, placeSearch, occupationSearch)
                );

                return mainMatch || familyMatch;
            });

            displayResults();
        }

        function matchesPerson(person, nameSearch, surnameSearch, typeFilter, placeSearch, occupationSearch) {
            const nameMatch = !nameSearch || person.name?.toLowerCase().includes(nameSearch);
            const surnameMatch = !surnameSearch ||
                person.surname?.toLowerCase().includes(surnameSearch) ||
                person.patronymic?.toLowerCase().includes(surnameSearch);
            const typeMatch = !typeFilter || person.type === typeFilter;
            const placeMatch = !placeSearch || person.place?.toLowerCase().includes(placeSearch);
            const occupationMatch = !occupationSearch || person.occupation?.toLowerCase().includes(occupationSearch);

            return nameMatch && surnameMatch && typeMatch && placeMatch && occupationMatch;
        }

        function matchesDates(dates, dateSearch) {
            if (!dateSearch) return true;
            return dates.year?.toLowerCase().includes(dateSearch) ||
                   dates.century?.toLowerCase().includes(dateSearch) ||
                   dates.period?.toLowerCase().includes(dateSearch);
        }

        function matchesManuscript(manuscript, manuscriptSearch) {
            if (!manuscriptSearch) return true;
            return manuscript.page?.toLowerCase().includes(manuscriptSearch) ||
                   manuscript.folio?.toLowerCase().includes(manuscriptSearch);
        }

        function clearSearch() {
            document.getElementById('nameSearch').value = '';
            document.getElementById('surnameSearch').value = '';
            document.getElementById('typeFilter').value = '';
            document.getElementById('placeSearch').value = '';
            document.getElementById('occupationSearch').value = '';
            document.getElementById('dateSearch').value = '';
            document.getElementById('manuscriptSearch').value = '';
            showAll();
        }

        function showAll() {
            currentResults = prosopographicalData;
            displayResults();
        }

        function setView(view) {
            currentView = view;
            document.getElementById('cardsBtn').classList.toggle('active', view === 'cards');
            document.getElementById('tableBtn').classList.toggle('active', view === 'table');
            displayResults();
        }

        function displayResults() {
            const container = document.getElementById('resultsContainer');
            const countElement = document.getElementById('resultsCount');
            const t = translations[currentLanguage];

            countElement.textContent = `${currentResults.length} ${t.entriesFound}`;

            if (currentResults.length === 0) {
                container.innerHTML = `<div class="no-results">${t.noEntriesFound}</div>`;
                return;
            }

            if (currentView === 'table') {
                displayTableView(container);
            } else {
                displayCardView(container);
            }
        }

        function displayCardView(container) {
            const html = currentResults.map(entry => createPersonCard(entry)).join('');
            container.innerHTML = html;
        }

        function displayTableView(container) {
            const t = translations[currentLanguage];
            let html = `
                <table>
                    <thead>
                        <tr>
                            <th>${t.tableHeaders.entry}</th>
                            <th>${t.tableHeaders.name}</th>
                            <th>${t.tableHeaders.surname}</th>
                            <th>${t.tableHeaders.type}</th>
                            <th>${t.tableHeaders.place}</th>
                            <th>${t.tableHeaders.occupation}</th>
                            <th>${t.tableHeaders.family}</th>
                            <th>${t.tableHeaders.msRef}</th>
                            <th>${t.tableHeaders.dates}</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            currentResults.forEach(entry => {
                const familyNames = entry.familyMembers ?
                    entry.familyMembers.map(m => `${m.name} (${getLocalizedType(m.type)})`).join(', ') : '';

                const dateInfo = [entry.dates?.year, entry.dates?.century].filter(d => d).join(' ');

                html += `
                    <tr>
                        <td>${entry.entryNumber}</td>
                        <td class="georgian-text">${entry.mainPerson.name}</td>
                        <td class="georgian-text">${entry.mainPerson.surname || entry.mainPerson.patronymic || ''}</td>
                        <td>${getLocalizedType(entry.mainPerson.type) || ''}</td>
                        <td class="georgian-text">${entry.mainPerson.place || ''}</td>
                        <td class="georgian-text">${entry.mainPerson.occupation || ''}</td>
                        <td class="georgian-text">${familyNames}</td>
                        <td>f. ${entry.manuscript.page || entry.manuscript.folio || ''}, l. ${entry.manuscript.line || ''}</td>
                        <td>${dateInfo}</td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function getLocalizedType(type) {
            const typeMap = {
                'main': { en: 'main', ka: 'მთავარი' },
                'wife': { en: 'wife', ka: 'მეუღლე' },
                'son': { en: 'son', ka: 'შვილი' },
                'daughter': { en: 'daughter', ka: 'ასული' },
                'brother': { en: 'brother', ka: 'ძმა' },
                'sister': { en: 'sister', ka: 'და' },
                'mother': { en: 'mother', ka: 'დედა' },
                'father': { en: 'father', ka: 'მამა' },
                'evangelist': { en: 'evangelist', ka: 'მახარებელი' },
                'bishop': { en: 'bishop', ka: 'ეპისკოპოსი' },
                'priest': { en: 'priest', ka: 'მღვდელი' },
                'monk': { en: 'monk', ka: 'ბერი' },
                'woman': { en: 'woman', ka: 'ქალი' }
            };

            return typeMap[type] ? typeMap[type][currentLanguage] : type;
        }

        function createPersonCard(entry) {
            const mainPerson = entry.mainPerson;
            const familyMembers = entry.familyMembers || [];
            const t = translations[currentLanguage];

            return `
                <div class="person-card">
                    <div class="person-name georgian-text">
                        ${mainPerson.name}
                        ${mainPerson.surname ? ` (${mainPerson.surname})` : ''}
                        ${mainPerson.patronymic ? ` (${mainPerson.patronymic})` : ''}
                    </div>
                    <div class="person-details">
                        <div class="detail-item">
                            <span class="detail-label">${t.entryLabel}</span>
                            <span>${entry.entryNumber}</span>
                        </div>
                        ${mainPerson.type ? `
                        <div class="detail-item">
                            <span class="detail-label">${t.typeLabel}</span>
                            <span>${getLocalizedType(mainPerson.type)}</span>
                        </div>
                        ` : ''}
                        ${mainPerson.place ? `
                        <div class="detail-item">
                            <span class="detail-label">${t.placeLabel}</span>
                            <span class="georgian-text">${mainPerson.place}</span>
                        </div>
                        ` : ''}
                        ${mainPerson.occupation ? `
                        <div class="detail-item">
                            <span class="detail-label">${t.occupationLabel}</span>
                            <span class="georgian-text">${mainPerson.occupation}</span>
                        </div>
                        ` : ''}
                        <div class="detail-item">
                            <span class="detail-label">${t.msLabel2}</span>
                            <span>f. ${entry.manuscript.page || entry.manuscript.folio || ''}, l. ${entry.manuscript.line || ''}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">${t.edLabel}</span>
                            <span>p. ${entry.edition.page || ''}, l. ${entry.edition.line || ''}</span>
                        </div>
                    </div>
                    ${(entry.dates?.year || entry.dates?.century || entry.dates?.period) ? `
                    <div class="dates-info">
                        <div class="family-title">${t.datesTitle}</div>
                        ${entry.dates?.year ? `Year: ${entry.dates.year} ` : ''}
                        ${entry.dates?.century ? `Century: ${entry.dates.century} ` : ''}
                        ${entry.dates?.period ? `Period: ${entry.dates.period}` : ''}
                    </div>
                    ` : ''}
                    ${familyMembers.length > 0 ? `
                    <div class="family-members">
                        <div class="family-title">${t.familyTitle}</div>
                        ${familyMembers.map(member => `
                            <span class="family-member georgian-text">
                                ${member.name} (${getLocalizedType(member.type)})
                            </span>
                        `).join('')}
                    </div>
                    ` : ''}
                    ${entry.notes ? `
                    <div class="dates-info">
                        <strong>Notes:</strong> ${entry.notes}
                    </div>
                    ` : ''}
                </div>
            `;
        }

        function exportData(format = 'csv') {
            const t = translations[currentLanguage];

            if (format === 'json') {
                const jsonData = {
                    metadata: {
                        title: "Ṭbetis sulta maṭiane",
                        description: "Complete Synodal Records from Ṭbeti - Prosopographical Database",
                        manuscript: "St. Petersburg, Russian National Library, P10/P13",
                        totalEntries: currentResults.length,
                        exportDate: new Date().toISOString(),
                        language: currentLanguage
                    },
                    entries: currentResults
                };

                const jsonContent = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(jsonData, null, 2));
                const link = document.createElement("a");
                link.setAttribute("href", jsonContent);
                link.setAttribute("download", "tbeti_prosopographical_data.json");
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else {
                // CSV export
                const csvContent = "data:text/csv;charset=utf-8," +
                    "Entry,Name,Surname,Type,Place,Occupation,Family_Members,MS_Reference,Dates,Notes\n" +
                    currentResults.map(entry => {
                        const familyNames = entry.familyMembers ?
                            entry.familyMembers.map(m => `${m.name}(${m.type})`).join(';') : '';
                        const msRef = `f.${entry.manuscript.page || entry.manuscript.folio || ''}_l.${entry.manuscript.line || ''}`;
                        const dateInfo = [entry.dates?.year, entry.dates?.century, entry.dates?.period].filter(d => d).join(' ');

                        return `${entry.entryNumber},"${entry.mainPerson.name}","${entry.mainPerson.surname || entry.mainPerson.patronymic || ''}","${entry.mainPerson.type || ''}","${entry.mainPerson.place || ''}","${entry.mainPerson.occupation || ''}","${familyNames}","${msRef}","${dateInfo}","${entry.notes || ''}"`;
                    }).join("\n");

                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                link.setAttribute("download", "tbeti_prosopographical_data.csv");
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        // File input event listener
        document.addEventListener('DOMContentLoaded', function() {
            const fileInput = document.getElementById('xmlFileInput');
            fileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    document.getElementById('fileStatus').textContent = `${translations[currentLanguage].fileSelected} ${file.name}`;
                } else {
                    document.getElementById('fileStatus').textContent = translations[currentLanguage].fileStatus;
                }
            });

            // Initialize with sample data
            loadSampleData();

            // Add search event listeners
            document.getElementById('nameSearch').addEventListener('input', performSearch);
            document.getElementById('surnameSearch').addEventListener('input', performSearch);
            document.getElementById('typeFilter').addEventListener('change', performSearch);
            document.getElementById('placeSearch').addEventListener('input', performSearch);
            document.getElementById('occupationSearch').addEventListener('input', performSearch);
            document.getElementById('dateSearch').addEventListener('input', performSearch);
            document.getElementById('manuscriptSearch').addEventListener('input', performSearch);
        });
    </script>
</body>
</html>
